#pragma once

#include <string>
#include <utility>
#include <vector>

#include "concurrent/thread_pool.h"
#include "func_register.h"

class TaskNode {
   public:
    TaskNode() = default;
    TaskNode(std::vector<std::string> input_names, KernelFunc func, std::string name)
        : input_names_(std::move(input_names)),
          func_(std::move(func)),
          node_name_(std::move(name)){};

    KernelFunc GetFunc() { return func_; }

    std::string GetName() { return node_name_; }

    void AddSuccessor(TaskNode* node) {
        successors_.push_back(node);
        node->deps_.push_back(this);
    }

    std::vector<TaskNode*> GetSuccessors() { return successors_; }
    std::vector<TaskNode*> GetDeps() { return deps_; }

   private:
    std::vector<std::string> input_names_;
    KernelFunc func_;
    std::string node_name_;

    std::vector<TaskNode*> deps_;
    std::vector<TaskNode*> successors_;
};

class Graph {
   public:
    Graph() { pool_ptr_ = std::make_unique<ThreadPool>(1); }

    void AddNode(TaskNode* node) {
        std::unique_ptr<TaskNode> ptr(node);
        nodes_.emplace_back(std::move(ptr));
    }

    std::vector<std::any> Run() {
        TaskNode* ready_nodes = nullptr;
        for (auto&& deps : nodes_deps_) {
            if (deps.second == 0) {
                ready_nodes = deps.first;
            }
        }
        pool_ptr_->Enqueue([this, ready_nodes] { Process(ready_nodes); });
        return std::vector<std::any>{};
    }

    void Build() {
        for (auto&& node : nodes_) {
            nodes_deps_.insert(std::make_pair(node.get(), 0));
        }

        for (const auto& node : nodes_) {
            for (const auto& successor : node->GetSuccessors()) {
                nodes_deps_[successor].fetch_add(1);
            }
        }
    }

   private:
    void Process(TaskNode* ready_nodes) {
        auto func = ready_nodes->GetFunc();
        KernelFrame frame;
        frame.AddInput(1);
        func(&frame);

        std::vector<TaskNode*> new_ready_nodes;
        for (auto&& successor : ready_nodes->GetSuccessors()) {
            if (nodes_deps_[successor].fetch_sub(1) == 1) {
                new_ready_nodes.emplace_back(successor);
            }
        };

        for (int i = 0; i < new_ready_nodes.size(); ++i) {
            pool_ptr_->Enqueue(
                [this, i, new_ready_nodes]() -> void { Process(new_ready_nodes[i]); });
        }
    }

    std::vector<std::unique_ptr<TaskNode>> nodes_;
    std::unordered_map<TaskNode*, std::atomic<int>> nodes_deps_;
    std::unique_ptr<ThreadPool> pool_ptr_;
};
